import { ReservationStatus } from "../entities/Reservation"
import { UserType, UserStatus } from "../entities/User"
import { VariationType } from "../entities/MenuVariation"
import { ReservationRepository } from "../repositories/ReservationRepository"
import { UserRepository } from "../repositories/UserRepository"
import { MenuRepository } from "../repositories/MenuRepository"
import { WeekDayManagementService } from "./WeekDayManagementService"
import { CreateReservationDTO } from "../../dtos/ReservationDTOs"
import { AppError, devError } from "@/app/shared"

export interface AutoReservationResult {
  userId: string
  userName: string
  success: boolean
  reservationId?: string
  error?: string
}

export interface AutoReservationBatchResult {
  totalUsers: number
  successfulReservations: number
  failedReservations: number
  results: AutoReservationResult[]
  processedAt: Date
}

export class AutoReservationService {
  constructor(
    private reservationRepository: ReservationRepository,
    private userRepository: UserRepository,
    private menuRepository: MenuRepository,
    private weekDayManagementService: WeekDayManagementService
  ) {}

  async createAutoReservationForUser(
    userId: string,
    date: Date
  ): Promise<AutoReservationResult> {
    try {
      // Validate user exists and is fixed type
      const user = await this.userRepository.findById(userId)
      if (!user) {
        return {
          userId,
          userName: "Unknown",
          success: false,
          error: "Usuário não encontrado",
        }
      }

      if (!user.isActive()) {
        return {
          userId,
          userName: user.name,
          success: false,
          error: "Usuário inativo",
        }
      }

      if (!user.isFixedUser()) {
        return {
          userId,
          userName: user.name,
          success: false,
          error: "Usuário não é do tipo fixo",
        }
      }

      // Check if user already has a reservation for this date
      const existingReservation =
        await this.reservationRepository.findByUserAndDate(userId, date)
      if (existingReservation && existingReservation.isActive()) {
        return {
          userId,
          userName: user.name,
          success: false,
          error: "Usuário já possui reserva para esta data",
        }
      }

      // Find menu for the date
      const menu = await this.menuRepository.findWithCompositionByDate(date)
      if (!menu) {
        return {
          userId,
          userName: user.name,
          success: false,
          error: "Cardápio não encontrado para esta data",
        }
      }

      if (!menu.isActive) {
        return {
          userId,
          userName: user.name,
          success: false,
          error: "Cardápio não está ativo",
        }
      }

      // Find default variation (standard)
      const defaultVariation = menu.variations.find(
        (v) => v.variationType === VariationType.STANDARD && v.isDefault
      )

      if (!defaultVariation) {
        return {
          userId,
          userName: user.name,
          success: false,
          error: "Variação padrão do cardápio não encontrada",
        }
      }

      // Create auto reservation
      const reservationData: CreateReservationDTO = {
        userId,
        menuId: menu.id,
        menuVariationId: defaultVariation.id,
        reservationDate: date,
        isAutoGenerated: true,
      }

      const createdReservation =
        await this.reservationRepository.create(reservationData)

      return {
        userId,
        userName: user.name,
        success: true,
        reservationId: createdReservation.id,
      }
    } catch (error) {
      const user = await this.userRepository.findById(userId).catch(() => null)
      return {
        userId,
        userName: user?.name || "Unknown",
        success: false,
        error: error instanceof Error ? error.message : "Erro desconhecido",
      }
    }
  }

  async createAutoReservationsForDate(
    date: Date
  ): Promise<AutoReservationBatchResult> {
    const startTime = new Date()

    // Validate date is a business day
    if (!this.weekDayManagementService.isBusinessDay(date)) {
      throw new AppError(
        "Reservas automáticas só podem ser criadas para dias úteis",
        400
      )
    }

    // Validate date is not in the past
    const today = new Date()
    today.setHours(0, 0, 0, 0)
    const targetDate = new Date(date)
    targetDate.setHours(0, 0, 0, 0)

    if (targetDate < today) {
      throw new AppError(
        "Não é possível criar reservas automáticas para data passada",
        400
      )
    }

    // Get all fixed users
    const allUsers = await this.userRepository.findAll()
    const fixedUsers = allUsers.filter(
      (user) =>
        user.userType === UserType.FIXO && user.status === UserStatus.ATIVO
    )

    if (fixedUsers.length === 0) {
      return {
        totalUsers: 0,
        successfulReservations: 0,
        failedReservations: 0,
        results: [],
        processedAt: startTime,
      }
    }

    // Process each fixed user
    const results: AutoReservationResult[] = []
    let successCount = 0
    let failureCount = 0

    for (const user of fixedUsers) {
      const result = await this.createAutoReservationForUser(user.id, date)
      results.push(result)

      if (result.success) {
        successCount++
      } else {
        failureCount++
      }
    }

    return {
      totalUsers: fixedUsers.length,
      successfulReservations: successCount,
      failedReservations: failureCount,
      results,
      processedAt: startTime,
    }
  }

  async createAutoReservationsForWeek(
    weekNumber: number,
    year?: number
  ): Promise<AutoReservationBatchResult[]> {
    const targetYear = year || new Date().getFullYear()
    const businessDates = this.weekDayManagementService.getBusinessDatesForWeek(
      weekNumber,
      targetYear
    )

    const weekResults: AutoReservationBatchResult[] = []

    for (const date of businessDates) {
      try {
        const dayResult = await this.createAutoReservationsForDate(date)
        weekResults.push(dayResult)
      } catch (error) {
        // Log error but continue with other dates
        devError(
          `Failed to create auto reservations for ${date.toISOString()}:`,
          error
        )

        weekResults.push({
          totalUsers: 0,
          successfulReservations: 0,
          failedReservations: 0,
          results: [],
          processedAt: new Date(),
        })
      }
    }

    return weekResults
  }

  async createAutoReservationsForDateRange(
    startDate: Date,
    endDate: Date
  ): Promise<AutoReservationBatchResult[]> {
    const businessDays = this.weekDayManagementService.getBusinessDaysInRange(
      startDate,
      endDate
    )
    const rangeResults: AutoReservationBatchResult[] = []

    for (const date of businessDays) {
      try {
        const dayResult = await this.createAutoReservationsForDate(date)
        rangeResults.push(dayResult)
      } catch (error) {
        // Log error but continue with other dates
        devError(
          `Failed to create auto reservations for ${date.toISOString()}:`,
          error
        )

        rangeResults.push({
          totalUsers: 0,
          successfulReservations: 0,
          failedReservations: 0,
          results: [],
          processedAt: new Date(),
        })
      }
    }

    return rangeResults
  }

  async cancelFutureAutoReservationsForUser(userId: string): Promise<{
    cancelledCount: number
    cancelledReservations: string[]
  }> {
    // Validate user exists
    const user = await this.userRepository.findById(userId)
    if (!user) {
      throw new AppError("Usuário não encontrado", 404)
    }

    // Get user's future auto-generated reservations
    const today = new Date()
    today.setHours(0, 0, 0, 0)

    const userReservations = await this.reservationRepository.findByUser(userId)
    const futureAutoReservations = userReservations.filter((reservation) => {
      const reservationDate = new Date(reservation.reservationDate)
      reservationDate.setHours(0, 0, 0, 0)

      return (
        reservation.isAutoGenerated &&
        reservation.isActive() &&
        reservationDate > today
      )
    })

    const cancelledReservations: string[] = []

    // Cancel each future auto reservation
    for (const reservation of futureAutoReservations) {
      try {
        await this.reservationRepository.update(reservation.id, {
          status: ReservationStatus.CANCELLED,
        })
        cancelledReservations.push(reservation.id)
      } catch (error) {
        devError(`Failed to cancel reservation ${reservation.id}:`, error)
      }
    }

    return {
      cancelledCount: cancelledReservations.length,
      cancelledReservations,
    }
  }

  async handleUserTypeChange(
    userId: string,
    newUserType: UserType
  ): Promise<void> {
    const user = await this.userRepository.findById(userId)
    if (!user) {
      throw new AppError("Usuário não encontrado", 404)
    }

    // If user is changing FROM fixed TO non-fixed, cancel future auto reservations
    if (user.userType === UserType.FIXO && newUserType === UserType.NAO_FIXO) {
      await this.cancelFutureAutoReservationsForUser(userId)
    }

    // If user is changing FROM non-fixed TO fixed, create auto reservations for available future dates
    if (user.userType === UserType.NAO_FIXO && newUserType === UserType.FIXO) {
      const today = new Date()
      const futureDate = new Date(today)
      futureDate.setDate(today.getDate() + 30) // Create reservations for next 30 days

      await this.createAutoReservationsForDateRange(today, futureDate)
    }
  }

  async getAutoReservationStatistics(
    startDate: Date,
    endDate: Date
  ): Promise<{
    totalAutoReservations: number
    activeAutoReservations: number
    cancelledAutoReservations: number
    fixedUsersCount: number
    averageReservationsPerUser: number
  }> {
    // Get all reservations in date range
    const allReservations = await this.reservationRepository.findByDateRange(
      startDate,
      endDate
    )
    const autoReservations = allReservations.filter((r) => r.isAutoGenerated)

    // Get fixed users count
    const allUsers = await this.userRepository.findAll()
    const fixedUsersCount = allUsers.filter(
      (user) =>
        user.userType === UserType.FIXO && user.status === UserStatus.ATIVO
    ).length

    return {
      totalAutoReservations: autoReservations.length,
      activeAutoReservations: autoReservations.filter((r) => r.isActive())
        .length,
      cancelledAutoReservations: autoReservations.filter((r) => r.isCancelled())
        .length,
      fixedUsersCount,
      averageReservationsPerUser:
        fixedUsersCount > 0 ? autoReservations.length / fixedUsersCount : 0,
    }
  }

  async processScheduledAutoReservations(): Promise<AutoReservationBatchResult> {
    // This method would be called by a scheduler (e.g., daily at midnight)
    // Create auto reservations for the next business day

    const tomorrow = new Date()
    tomorrow.setDate(tomorrow.getDate() + 1)

    // Only process if tomorrow is a business day
    if (!this.weekDayManagementService.isBusinessDay(tomorrow)) {
      return {
        totalUsers: 0,
        successfulReservations: 0,
        failedReservations: 0,
        results: [],
        processedAt: new Date(),
      }
    }

    return await this.createAutoReservationsForDate(tomorrow)
  }

  async retryFailedAutoReservations(
    batchResult: AutoReservationBatchResult
  ): Promise<AutoReservationBatchResult> {
    const failedResults = batchResult.results.filter((r) => !r.success)

    if (failedResults.length === 0) {
      return batchResult
    }

    // Extract date from the original batch (assuming all reservations were for the same date)
    // In a real implementation, you might want to pass the date as a parameter
    const retryResults: AutoReservationResult[] = []
    const successCount = 0
    let failureCount = 0

    for (const failedResult of failedResults) {
      // Retry logic would go here
      // For now, we'll just return the original failed result
      retryResults.push(failedResult)
      failureCount++
    }

    return {
      totalUsers: failedResults.length,
      successfulReservations: successCount,
      failedReservations: failureCount,
      results: retryResults,
      processedAt: new Date(),
    }
  }
}
