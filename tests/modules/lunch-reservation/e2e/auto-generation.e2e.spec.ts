import { describe, it, expect, beforeEach } from "vitest"
import request from "supertest"
import { app } from "../../../shared/helpers/app"
import { prisma } from "../../../../src/infrastructure/database/prisma"
import { makeAuthModule } from "../../../../src/app/modules/auth"

interface ReservationResponse {
  id: string
  isAutoGenerated: boolean
  status: string
  userId: string
  menuVariationId: string
  updatedAt: string
}

describe("Lunch Reservation Auto-Generation E2E Tests", () => {
  // Use the auth module's AuthService for password hashing (same as the controller uses)
  const { authService } = makeAuthModule()

  let fixedUserToken: string
  let nonFixedUserToken: string
  let adminToken: string
  let fixedUserId: string
  let nonFixedUserId: string
  let testMenuId: string
  let testMenuVariationId: string

  beforeEach(async () => {
    // Clean up database
    await prisma.reservation.deleteMany()
    await prisma.menuVariation.deleteMany()
    await prisma.menuComposition.deleteMany()
    await prisma.menu.deleteMany()
    await prisma.menuItem.deleteMany()
    await prisma.category.deleteMany()
    await prisma.user.deleteMany()

    // Create test users
    const fixedUser = await prisma.user.create({
      data: {
        cpf: "11144477735",
        password: await authService.hashPassword("hello123"),
        name: "Fixed User",
        role: "USER",
        userType: "FIXO",
        status: "ATIVO",
      },
    })
    fixedUserId = fixedUser.id

    const nonFixedUser = await prisma.user.create({
      data: {
        cpf: "22255588846",
        password: await authService.hashPassword("hello123"),
        name: "Non-Fixed User",
        role: "USER",
        userType: "NAO_FIXO",
        status: "ATIVO",
      },
    })
    nonFixedUserId = nonFixedUser.id

    await prisma.user.create({
      data: {
        cpf: "33366699957",
        password: await authService.hashPassword("hello123"),
        name: "Admin User",
        role: "ADMIN",
        userType: "NAO_FIXO",
        status: "ATIVO",
      },
    })

    // Get authentication tokens
    const fixedUserLoginResponse = await request(app)
      .post("/api/lunch-reservation/auth/login")
      .send({
        cpf: "11144477735",
        password: "hello123",
      })

    const nonFixedUserLoginResponse = await request(app)
      .post("/api/lunch-reservation/auth/login")
      .send({
        cpf: "22255588846",
        password: "hello123",
      })

    const adminLoginResponse = await request(app)
      .post("/api/lunch-reservation/auth/login")
      .send({
        cpf: "33366699957",
        password: "hello123",
      })

    fixedUserToken = fixedUserLoginResponse.body.token
    nonFixedUserToken = nonFixedUserLoginResponse.body.token
    adminToken = adminLoginResponse.body.token

    // Create test data structure
    const testCategory = await prisma.category.create({
      data: {
        name: "Proteínas",
        description: "Categoria de proteínas",
        displayOrder: 1,
        isActive: true,
      },
    })

    const testMenuItem = await prisma.menuItem.create({
      data: {
        name: "Frango Grelhado",
        description: "Frango grelhado com temperos",
        categoryId: testCategory.id,
        isActive: true,
      },
    })

    const tomorrow = new Date()
    tomorrow.setDate(tomorrow.getDate() + 1)
    tomorrow.setHours(0, 0, 0, 0)

    const testMenu = await prisma.menu.create({
      data: {
        date: tomorrow,
        dayOfWeek: "TUESDAY",
        weekNumber: 50,
        observations: "Menu de teste",
        isActive: true,
      },
    })
    testMenuId = testMenu.id

    const testMenuVariation = await prisma.menuVariation.create({
      data: {
        menuId: testMenu.id,
        variationType: "STANDARD",
        proteinItemId: testMenuItem.id,
        isDefault: true,
      },
    })
    testMenuVariationId = testMenuVariation.id

    await prisma.menuComposition.create({
      data: {
        menuId: testMenu.id,
        menuItemId: testMenuItem.id,
        observations: "Proteína principal",
        isMainProtein: true,
        isAlternativeProtein: false,
      },
    })
  })

  describe("Auto-Generated Reservations for Fixed Users", () => {
    it("should simulate auto-generation by creating reservations marked as auto-generated", async () => {
      const tomorrow = new Date()
      tomorrow.setDate(tomorrow.getDate() + 1)

      // Simulate the auto-generation process by creating a reservation directly
      // In a real scenario, this would be done by the scheduler
      const autoGeneratedReservation = await prisma.reservation.create({
        data: {
          userId: fixedUserId,
          menuId: testMenuId,
          menuVariationId: testMenuVariationId,
          reservationDate: tomorrow,
          status: "ACTIVE",
          isAutoGenerated: true,
        },
      })

      // Fixed user checks their reservations and finds the auto-generated one
      const reservationsResponse = await request(app)
        .get("/api/lunch-reservation/reservations")
        .set("Authorization", `Bearer ${fixedUserToken}`)
        .expect(200)

      expect(reservationsResponse.body).toHaveLength(1)
      expect(reservationsResponse.body[0].id).toBe(autoGeneratedReservation.id)
      expect(reservationsResponse.body[0].isAutoGenerated).toBe(true)
      expect(reservationsResponse.body[0].status).toBe("ACTIVE")
    })

    it("should allow fixed user to modify auto-generated reservation", async () => {
      const tomorrow = new Date()
      tomorrow.setDate(tomorrow.getDate() + 1)

      // Create auto-generated reservation
      const autoGeneratedReservation = await prisma.reservation.create({
        data: {
          userId: fixedUserId,
          menuId: testMenuId,
          menuVariationId: testMenuVariationId,
          reservationDate: tomorrow,
          status: "ACTIVE",
          isAutoGenerated: true,
        },
      })

      // Create alternative menu variation
      const alternativeMenuItem = await prisma.menuItem.create({
        data: {
          name: "Ovo Mexido",
          description: "Ovo mexido como alternativa",
          categoryId: (await prisma.category.findFirst())!.id,
          isActive: true,
        },
      })

      const alternativeMenuVariation = await prisma.menuVariation.create({
        data: {
          menuId: testMenuId,
          variationType: "EGG_SUBSTITUTE",
          proteinItemId: alternativeMenuItem.id,
          isDefault: false,
        },
      })

      // Fixed user modifies the auto-generated reservation
      const updateResponse = await request(app)
        .put(
          `/api/lunch-reservation/reservations/${autoGeneratedReservation.id}`
        )
        .set("Authorization", `Bearer ${fixedUserToken}`)
        .send({
          menuVariationId: alternativeMenuVariation.id,
        })
        .expect(200)

      expect(updateResponse.body.menuVariationId).toBe(
        alternativeMenuVariation.id
      )
      expect(updateResponse.body.isAutoGenerated).toBe(true) // Should remain auto-generated
    })

    it("should allow fixed user to cancel auto-generated reservation", async () => {
      const tomorrow = new Date()
      tomorrow.setDate(tomorrow.getDate() + 1)

      // Create auto-generated reservation
      const autoGeneratedReservation = await prisma.reservation.create({
        data: {
          userId: fixedUserId,
          menuId: testMenuId,
          menuVariationId: testMenuVariationId,
          reservationDate: tomorrow,
          status: "ACTIVE",
          isAutoGenerated: true,
        },
      })

      // Fixed user cancels the auto-generated reservation
      const cancelResponse = await request(app)
        .delete(
          `/api/lunch-reservation/reservations/${autoGeneratedReservation.id}`
        )
        .set("Authorization", `Bearer ${fixedUserToken}`)
        .expect(200)

      expect(cancelResponse.body.status).toBe("CANCELLED")
      expect(cancelResponse.body.isAutoGenerated).toBe(true)

      // Verify reservation is no longer active
      const activeReservationsResponse = await request(app)
        .get("/api/lunch-reservation/reservations/active")
        .set("Authorization", `Bearer ${fixedUserToken}`)
        .expect(200)

      expect(activeReservationsResponse.body).toHaveLength(0)
    })

    it("should prevent duplicate reservations when auto-generation conflicts with manual reservation", async () => {
      const tomorrow = new Date()
      tomorrow.setDate(tomorrow.getDate() + 1)
      // Normalize the date to ensure consistent comparison
      const normalizedDate = new Date(
        tomorrow.toISOString().split("T")[0] + "T00:00:00.000Z"
      )

      // Fixed user creates manual reservation first
      const manualReservationResponse = await request(app)
        .post("/api/lunch-reservation/reservations")
        .set("Authorization", `Bearer ${fixedUserToken}`)
        .send({
          menuId: testMenuId,
          menuVariationId: testMenuVariationId,
          reservationDate: normalizedDate.toISOString(),
        })
        .expect(201)

      expect(manualReservationResponse.body.isAutoGenerated).toBe(false)

      // Simulate auto-generation attempt (should fail due to existing reservation)
      // This would normally be handled by the scheduler's business logic
      const duplicateReservationAttempt = prisma.reservation.create({
        data: {
          userId: fixedUserId,
          menuId: testMenuId,
          menuVariationId: testMenuVariationId,
          reservationDate: normalizedDate,
          status: "ACTIVE",
          isAutoGenerated: true,
        },
      })

      // Should fail due to unique constraint on userId + reservationDate
      await expect(duplicateReservationAttempt).rejects.toThrow()
    })
  })

  describe("Fixed vs Non-Fixed User Behavior", () => {
    it("should show different reservation patterns for fixed and non-fixed users", async () => {
      const tomorrow = new Date()
      tomorrow.setDate(tomorrow.getDate() + 1)

      // Create auto-generated reservation for fixed user
      await prisma.reservation.create({
        data: {
          userId: fixedUserId,
          menuId: testMenuId,
          menuVariationId: testMenuVariationId,
          reservationDate: tomorrow,
          status: "ACTIVE",
          isAutoGenerated: true,
        },
      })

      // Create menu for day after tomorrow
      const dayAfterTomorrow = new Date(
        tomorrow.getTime() + 24 * 60 * 60 * 1000
      )
      const dayAfterTomorrowMenu = await prisma.menu.create({
        data: {
          date: dayAfterTomorrow,
          dayOfWeek: "WEDNESDAY",
          weekNumber: 50,
          observations: "Menu day after tomorrow",
          isActive: true,
        },
      })

      const dayAfterTomorrowMenuVariation = await prisma.menuVariation.create({
        data: {
          menuId: dayAfterTomorrowMenu.id,
          variationType: "STANDARD",
          proteinItemId: (await prisma.menuItem.findFirst())!.id,
          isDefault: true,
        },
      })

      // Non-fixed user creates manual reservation
      await request(app)
        .post("/api/lunch-reservation/reservations")
        .set("Authorization", `Bearer ${nonFixedUserToken}`)
        .send({
          menuId: dayAfterTomorrowMenu.id,
          menuVariationId: dayAfterTomorrowMenuVariation.id,
          reservationDate: dayAfterTomorrow.toISOString(),
        })
        .expect(201)

      // Check fixed user reservations (should have auto-generated)
      const fixedUserReservationsResponse = await request(app)
        .get("/api/lunch-reservation/reservations")
        .set("Authorization", `Bearer ${fixedUserToken}`)
        .expect(200)

      expect(fixedUserReservationsResponse.body).toHaveLength(1)
      expect(fixedUserReservationsResponse.body[0].isAutoGenerated).toBe(true)

      // Check non-fixed user reservations (should have manual)
      const nonFixedUserReservationsResponse = await request(app)
        .get("/api/lunch-reservation/reservations")
        .set("Authorization", `Bearer ${nonFixedUserToken}`)
        .expect(200)

      expect(nonFixedUserReservationsResponse.body).toHaveLength(1)
      expect(nonFixedUserReservationsResponse.body[0].isAutoGenerated).toBe(
        false
      )
    })

    it("should allow non-fixed users to create only manual reservations", async () => {
      const tomorrow = new Date()
      tomorrow.setDate(tomorrow.getDate() + 1)

      // Non-fixed user creates reservation
      const reservationResponse = await request(app)
        .post("/api/lunch-reservation/reservations")
        .set("Authorization", `Bearer ${nonFixedUserToken}`)
        .send({
          menuId: testMenuId,
          menuVariationId: testMenuVariationId,
          reservationDate: tomorrow.toISOString(),
        })
        .expect(201)

      expect(reservationResponse.body.isAutoGenerated).toBe(false)
      expect(reservationResponse.body.userId).toBe(nonFixedUserId)
    })
  })

  describe("Admin View of Auto-Generated Reservations", () => {
    it("should allow admin to distinguish between auto-generated and manual reservations", async () => {
      const tomorrow = new Date()
      tomorrow.setDate(tomorrow.getDate() + 1)

      const dayAfterTomorrow = new Date(
        tomorrow.getTime() + 24 * 60 * 60 * 1000
      )

      // Create auto-generated reservation for fixed user
      await prisma.reservation.create({
        data: {
          userId: fixedUserId,
          menuId: testMenuId,
          menuVariationId: testMenuVariationId,
          reservationDate: tomorrow,
          status: "ACTIVE",
          isAutoGenerated: true,
        },
      })

      // Create menu for day after tomorrow
      const dayAfterTomorrowMenu = await prisma.menu.create({
        data: {
          date: dayAfterTomorrow,
          dayOfWeek: "WEDNESDAY",
          weekNumber: 50,
          observations: "Menu day after tomorrow",
          isActive: true,
        },
      })

      const dayAfterTomorrowMenuVariation = await prisma.menuVariation.create({
        data: {
          menuId: dayAfterTomorrowMenu.id,
          variationType: "STANDARD",
          proteinItemId: (await prisma.menuItem.findFirst())!.id,
          isDefault: true,
        },
      })

      // Create manual reservation for non-fixed user
      await request(app)
        .post("/api/lunch-reservation/reservations")
        .set("Authorization", `Bearer ${nonFixedUserToken}`)
        .send({
          menuId: dayAfterTomorrowMenu.id,
          menuVariationId: dayAfterTomorrowMenuVariation.id,
          reservationDate: dayAfterTomorrow.toISOString(),
        })
        .expect(201)

      // Admin views all reservations
      const adminReservationsResponse = await request(app)
        .get("/api/lunch-reservation/admin/reservations")
        .set("Authorization", `Bearer ${adminToken}`)
        .expect(200)

      expect(adminReservationsResponse.body).toHaveLength(2)

      const autoGeneratedReservation = adminReservationsResponse.body.find(
        (r: ReservationResponse) => r.isAutoGenerated === true
      )
      const manualReservation = adminReservationsResponse.body.find(
        (r: ReservationResponse) => r.isAutoGenerated === false
      )

      expect(autoGeneratedReservation).toBeDefined()
      expect(autoGeneratedReservation.userId).toBe(fixedUserId)

      expect(manualReservation).toBeDefined()
      expect(manualReservation.userId).toBe(nonFixedUserId)
    })

    it("should show reservation statistics including auto-generated vs manual", async () => {
      const tomorrow = new Date()
      tomorrow.setDate(tomorrow.getDate() + 1)

      // Create multiple reservations of different types
      await prisma.reservation.createMany({
        data: [
          {
            userId: fixedUserId,
            menuId: testMenuId,
            menuVariationId: testMenuVariationId,
            reservationDate: tomorrow,
            status: "ACTIVE",
            isAutoGenerated: true,
          },
          {
            userId: nonFixedUserId,
            menuId: testMenuId,
            menuVariationId: testMenuVariationId,
            reservationDate: new Date(tomorrow.getTime() + 24 * 60 * 60 * 1000),
            status: "ACTIVE",
            isAutoGenerated: false,
          },
        ],
      })

      // Admin views all reservations to analyze patterns
      const adminReservationsResponse = await request(app)
        .get("/api/lunch-reservation/admin/reservations")
        .set("Authorization", `Bearer ${adminToken}`)
        .expect(200)

      const autoGeneratedCount = adminReservationsResponse.body.filter(
        (r: ReservationResponse) => r.isAutoGenerated === true
      ).length

      const manualCount = adminReservationsResponse.body.filter(
        (r: ReservationResponse) => r.isAutoGenerated === false
      ).length

      expect(autoGeneratedCount).toBe(1)
      expect(manualCount).toBe(1)
      expect(adminReservationsResponse.body).toHaveLength(2)
    })
  })

  describe("Business Rules for Auto-Generated Reservations", () => {
    it("should respect cutoff time for modifying auto-generated reservations", async () => {
      const tomorrow = new Date()
      tomorrow.setDate(tomorrow.getDate() + 1)

      // Create auto-generated reservation
      const autoGeneratedReservation = await prisma.reservation.create({
        data: {
          userId: fixedUserId,
          menuId: testMenuId,
          menuVariationId: testMenuVariationId,
          reservationDate: tomorrow,
          status: "ACTIVE",
          isAutoGenerated: true,
        },
      })

      // Test modification (should work if within cutoff time)
      const updateResponse = await request(app)
        .put(
          `/api/lunch-reservation/reservations/${autoGeneratedReservation.id}`
        )
        .set("Authorization", `Bearer ${fixedUserToken}`)
        .send({
          menuVariationId: testMenuVariationId,
        })

      // The response depends on current time vs cutoff time
      if (updateResponse.status === 200) {
        expect(updateResponse.body.isAutoGenerated).toBe(true)
      } else {
        expect(updateResponse.status).toBe(400)
        expect(updateResponse.body.error).toContain("prazo")
      }
    })

    it("should handle inactive fixed users correctly", async () => {
      // Deactivate the fixed user
      await prisma.user.update({
        where: { id: fixedUserId },
        data: { status: "INATIVO" },
      })

      // Try to login with inactive fixed user
      const loginResponse = await request(app)
        .post("/api/lunch-reservation/auth/login")
        .send({
          cpf: "11144477735",
          password: "hello123",
        })
        .expect(403)

      expect(loginResponse.body.error).toBe("Usuário inativo")

      // Verify no auto-generated reservations should be created for inactive users
      // (This would be handled by the scheduler's business logic)
    })
  })
})
