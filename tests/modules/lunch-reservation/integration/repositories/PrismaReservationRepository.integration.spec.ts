import { describe, it, expect, beforeEach } from "vitest"
import { PrismaReservationRepository } from "../../../../../src/app/modules/lunch-reservation/infrastructure/repositories/PrismaReservationRepository"
import {
  Reservation,
  ReservationStatus,
} from "../../../../../src/app/modules/lunch-reservation/domain/entities/Reservation"
import {
  CreateReservationDTO,
  UpdateReservationDTO,
} from "../../../../../src/app/modules/lunch-reservation/dtos/ReservationDTOs"
import { prisma } from "../../../../../src/infrastructure/database/prisma"

describe("PrismaReservationRepository Integration Tests", () => {
  let repository: PrismaReservationRepository
  let testUserId: string
  let testMenuId: string
  let testMenuVariationId: string

  beforeEach(async () => {
    repository = new PrismaReservationRepository(prisma)

    // Clean up tables
    await prisma.reservation.deleteMany()
    await prisma.menuVariation.deleteMany()
    await prisma.menuComposition.deleteMany()
    await prisma.menu.deleteMany()
    await prisma.menuItem.deleteMany()
    await prisma.category.deleteMany()
    await prisma.user.deleteMany()

    // Create test user
    const testUser = await prisma.user.create({
      data: {
        cpf: "11144477735",
        password: "hashedPassword",
        name: "Test User",
        role: "USER",
        userType: "NAO_FIXO",
        status: "ATIVO",
      },
    })
    testUserId = testUser.id

    // Create test category
    const testCategory = await prisma.category.create({
      data: {
        name: "Test Category",
        description: "Test category description",
        displayOrder: 1,
        isActive: true,
      },
    })

    // Create test menu item
    const testMenuItem = await prisma.menuItem.create({
      data: {
        name: "Test Menu Item",
        description: "Test menu item description",
        categoryId: testCategory.id,
        isActive: true,
      },
    })

    // Create test menu
    const testMenu = await prisma.menu.create({
      data: {
        date: new Date("2024-12-10"),
        dayOfWeek: "TUESDAY",
        weekNumber: 50,
        observations: "Test menu",
        isActive: true,
      },
    })
    testMenuId = testMenu.id

    // Create test menu variation
    const testMenuVariation = await prisma.menuVariation.create({
      data: {
        menuId: testMenu.id,
        variationType: "STANDARD",
        proteinItemId: testMenuItem.id,
        isDefault: true,
      },
    })
    testMenuVariationId = testMenuVariation.id
  })

  describe("create", () => {
    it("should create a new reservation", async () => {
      const reservationData: CreateReservationDTO = {
        userId: testUserId,
        menuId: testMenuId,
        menuVariationId: testMenuVariationId,
        reservationDate: new Date("2024-12-10"),
        isAutoGenerated: false,
      }

      const createdReservation = await repository.create(reservationData)

      expect(createdReservation).toBeInstanceOf(Reservation)
      expect(createdReservation.userId).toBe(reservationData.userId)
      expect(createdReservation.menuId).toBe(reservationData.menuId)
      expect(createdReservation.menuVariationId).toBe(
        reservationData.menuVariationId
      )
      expect(createdReservation.reservationDate).toEqual(
        reservationData.reservationDate
      )
      expect(createdReservation.status).toBe(ReservationStatus.ACTIVE)
      expect(createdReservation.isAutoGenerated).toBe(false)
      expect(createdReservation.id).toBeDefined()
      expect(createdReservation.createdAt).toBeDefined()
      expect(createdReservation.updatedAt).toBeDefined()
    })

    it("should create auto-generated reservation", async () => {
      const reservationData: CreateReservationDTO = {
        userId: testUserId,
        menuId: testMenuId,
        menuVariationId: testMenuVariationId,
        reservationDate: new Date("2024-12-10"),
        isAutoGenerated: true,
      }

      const createdReservation = await repository.create(reservationData)

      expect(createdReservation.isAutoGenerated).toBe(true)
    })

    it("should enforce unique constraint on userId and reservationDate", async () => {
      const reservationData: CreateReservationDTO = {
        userId: testUserId,
        menuId: testMenuId,
        menuVariationId: testMenuVariationId,
        reservationDate: new Date("2024-12-10"),
      }

      await repository.create(reservationData)

      // Try to create another reservation for same user and date
      await expect(repository.create(reservationData)).rejects.toThrow()
    })
  })

  describe("findById", () => {
    it("should find reservation by ID", async () => {
      const reservationData: CreateReservationDTO = {
        userId: testUserId,
        menuId: testMenuId,
        menuVariationId: testMenuVariationId,
        reservationDate: new Date("2024-12-10"),
      }

      const createdReservation = await repository.create(reservationData)
      const foundReservation = await repository.findById(createdReservation.id)

      expect(foundReservation).not.toBeNull()
      expect(foundReservation!.id).toBe(createdReservation.id)
      expect(foundReservation!.userId).toBe(reservationData.userId)
      expect(foundReservation!.menuId).toBe(reservationData.menuId)
    })

    it("should return null when reservation does not exist", async () => {
      const foundReservation = await repository.findById(
        "550e8400-e29b-41d4-a716-446655440000"
      )

      expect(foundReservation).toBeNull()
    })
  })

  describe("findByUser", () => {
    it("should find all reservations for a user ordered by date (newest first)", async () => {
      const reservation1Data: CreateReservationDTO = {
        userId: testUserId,
        menuId: testMenuId,
        menuVariationId: testMenuVariationId,
        reservationDate: new Date("2024-12-10"),
      }

      const reservation2Data: CreateReservationDTO = {
        userId: testUserId,
        menuId: testMenuId,
        menuVariationId: testMenuVariationId,
        reservationDate: new Date("2024-12-12"),
      }

      await repository.create(reservation1Data)
      await repository.create(reservation2Data)

      const userReservations = await repository.findByUser(testUserId)

      expect(userReservations).toHaveLength(2)
      // Should be ordered by reservation date (newest first)
      expect(userReservations[0].reservationDate).toEqual(
        new Date("2024-12-12")
      )
      expect(userReservations[1].reservationDate).toEqual(
        new Date("2024-12-10")
      )
    })

    it("should return empty array when user has no reservations", async () => {
      const userReservations = await repository.findByUser(testUserId)

      expect(userReservations).toEqual([])
    })
  })

  describe("findByUserAndDate", () => {
    it("should find reservation by user and date", async () => {
      const reservationDate = new Date("2024-12-10")
      const reservationData: CreateReservationDTO = {
        userId: testUserId,
        menuId: testMenuId,
        menuVariationId: testMenuVariationId,
        reservationDate,
      }

      const createdReservation = await repository.create(reservationData)
      const foundReservation = await repository.findByUserAndDate(
        testUserId,
        reservationDate
      )

      expect(foundReservation).not.toBeNull()
      expect(foundReservation!.id).toBe(createdReservation.id)
      expect(foundReservation!.userId).toBe(testUserId)
    })

    it("should handle date normalization correctly", async () => {
      const reservationDate = new Date("2024-12-10T10:30:00.000Z")
      const reservationData: CreateReservationDTO = {
        userId: testUserId,
        menuId: testMenuId,
        menuVariationId: testMenuVariationId,
        reservationDate,
      }

      await repository.create(reservationData)

      // Search with different time but same date
      const searchDate = new Date("2024-12-10T15:45:00.000Z")
      const foundReservation = await repository.findByUserAndDate(
        testUserId,
        searchDate
      )

      expect(foundReservation).not.toBeNull()
    })

    it("should return null when no reservation exists for user and date", async () => {
      const foundReservation = await repository.findByUserAndDate(
        testUserId,
        new Date("2024-12-15")
      )

      expect(foundReservation).toBeNull()
    })
  })

  describe("findActiveReservationsForDate", () => {
    it("should find only active reservations for a specific date", async () => {
      const reservationDate = new Date("2024-12-10")

      // Create second user for multiple reservations
      const secondUser = await prisma.user.create({
        data: {
          cpf: "22255588846",
          password: "hashedPassword",
          name: "Second User",
          role: "USER",
          userType: "NAO_FIXO",
          status: "ATIVO",
        },
      })

      // Create active reservation
      await repository.create({
        userId: testUserId,
        menuId: testMenuId,
        menuVariationId: testMenuVariationId,
        reservationDate,
      })

      // Create another active reservation
      await repository.create({
        userId: secondUser.id,
        menuId: testMenuId,
        menuVariationId: testMenuVariationId,
        reservationDate,
      })

      // Create cancelled reservation
      const cancelledReservation = await repository.create({
        userId: testUserId,
        menuId: testMenuId,
        menuVariationId: testMenuVariationId,
        reservationDate: new Date("2024-12-11"),
      })

      // Cancel the reservation
      await repository.update(cancelledReservation.id, {
        status: ReservationStatus.CANCELLED,
      })

      const activeReservations =
        await repository.findActiveReservationsForDate(reservationDate)

      expect(activeReservations).toHaveLength(2)
      expect(
        activeReservations.every((r) => r.status === ReservationStatus.ACTIVE)
      ).toBe(true)
      expect(
        activeReservations.every(
          (r) =>
            r.reservationDate.toDateString() === reservationDate.toDateString()
        )
      ).toBe(true)
    })

    it("should return empty array when no active reservations exist for date", async () => {
      const activeReservations = await repository.findActiveReservationsForDate(
        new Date("2024-12-15")
      )

      expect(activeReservations).toEqual([])
    })
  })

  describe("findByDateRange", () => {
    it("should find reservations within date range", async () => {
      const startDate = new Date("2024-12-10")
      const endDate = new Date("2024-12-15")

      // Create reservations within range
      await repository.create({
        userId: testUserId,
        menuId: testMenuId,
        menuVariationId: testMenuVariationId,
        reservationDate: new Date("2024-12-10"),
      })

      await repository.create({
        userId: testUserId,
        menuId: testMenuId,
        menuVariationId: testMenuVariationId,
        reservationDate: new Date("2024-12-12"),
      })

      // Create reservation outside range
      await repository.create({
        userId: testUserId,
        menuId: testMenuId,
        menuVariationId: testMenuVariationId,
        reservationDate: new Date("2024-12-20"),
      })

      const reservationsInRange = await repository.findByDateRange(
        startDate,
        endDate
      )

      expect(reservationsInRange).toHaveLength(2)
      expect(
        reservationsInRange.every(
          (r) => r.reservationDate >= startDate && r.reservationDate <= endDate
        )
      ).toBe(true)
    })
  })

  describe("update", () => {
    it("should update reservation status", async () => {
      const reservationData: CreateReservationDTO = {
        userId: testUserId,
        menuId: testMenuId,
        menuVariationId: testMenuVariationId,
        reservationDate: new Date("2024-12-10"),
      }

      const createdReservation = await repository.create(reservationData)

      const updateData: UpdateReservationDTO = {
        status: ReservationStatus.CANCELLED,
      }

      const updatedReservation = await repository.update(
        createdReservation.id,
        updateData
      )

      expect(updatedReservation.id).toBe(createdReservation.id)
      expect(updatedReservation.status).toBe(ReservationStatus.CANCELLED)
      expect(updatedReservation.updatedAt!.getTime()).toBeGreaterThan(
        createdReservation.updatedAt!.getTime()
      )
    })

    it("should update menu variation", async () => {
      // Create another menu variation
      const anotherMenuItem = await prisma.menuItem.create({
        data: {
          name: "Another Menu Item",
          description: "Another menu item description",
          categoryId: (await prisma.category.findFirst())!.id,
          isActive: true,
        },
      })

      const anotherMenuVariation = await prisma.menuVariation.create({
        data: {
          menuId: testMenuId,
          variationType: "EGG_SUBSTITUTE",
          proteinItemId: anotherMenuItem.id,
          isDefault: false,
        },
      })

      const reservationData: CreateReservationDTO = {
        userId: testUserId,
        menuId: testMenuId,
        menuVariationId: testMenuVariationId,
        reservationDate: new Date("2024-12-10"),
      }

      const createdReservation = await repository.create(reservationData)

      const updateData: UpdateReservationDTO = {
        menuVariationId: anotherMenuVariation.id,
      }

      const updatedReservation = await repository.update(
        createdReservation.id,
        updateData
      )

      expect(updatedReservation.menuVariationId).toBe(anotherMenuVariation.id)
    })

    it("should throw error when updating non-existent reservation", async () => {
      const updateData: UpdateReservationDTO = {
        status: ReservationStatus.CANCELLED,
      }

      await expect(
        repository.update("550e8400-e29b-41d4-a716-446655440000", updateData)
      ).rejects.toThrow()
    })
  })

  describe("delete", () => {
    it("should delete reservation by ID", async () => {
      const reservationData: CreateReservationDTO = {
        userId: testUserId,
        menuId: testMenuId,
        menuVariationId: testMenuVariationId,
        reservationDate: new Date("2024-12-10"),
      }

      const createdReservation = await repository.create(reservationData)

      await repository.delete(createdReservation.id)

      const foundReservation = await repository.findById(createdReservation.id)
      expect(foundReservation).toBeNull()
    })

    it("should throw error when deleting non-existent reservation", async () => {
      await expect(
        repository.delete("550e8400-e29b-41d4-a716-446655440000")
      ).rejects.toThrow()
    })
  })

  describe("database relationships and constraints", () => {
    it("should maintain foreign key relationships", async () => {
      const reservationData: CreateReservationDTO = {
        userId: testUserId,
        menuId: testMenuId,
        menuVariationId: testMenuVariationId,
        reservationDate: new Date("2024-12-10"),
      }

      const createdReservation = await repository.create(reservationData)

      // Verify the reservation exists in database with proper relationships
      const dbReservation = await prisma.reservation.findUnique({
        where: { id: createdReservation.id },
        include: {
          user: true,
          menu: true,
          menuVariation: true,
        },
      })

      expect(dbReservation).not.toBeNull()
      expect(dbReservation!.user.id).toBe(testUserId)
      expect(dbReservation!.menu.id).toBe(testMenuId)
      expect(dbReservation!.menuVariation.id).toBe(testMenuVariationId)
    })

    it("should handle concurrent reservation creation for different dates", async () => {
      const reservationPromises = Array.from({ length: 3 }, (_, i) =>
        repository.create({
          userId: testUserId,
          menuId: testMenuId,
          menuVariationId: testMenuVariationId,
          reservationDate: new Date(`2024-12-${10 + i}`),
        })
      )

      const reservations = await Promise.all(reservationPromises)

      expect(reservations).toHaveLength(3)
      reservations.forEach((reservation, index) => {
        expect(reservation.reservationDate).toEqual(
          new Date(`2024-12-${10 + index}`)
        )
      })
    })
  })
})
